"""dashboard.py"""

import pandas as pd
import numpy as np
import streamlit as st
import re

from company_analysis import CompanyAnalysis
from financial_statement_config import FINANCIAL_STATEMENTS_CONFIG, AccountingItemKeys

from edgar import set_identity


ACCOUNTING_ITEMS_CONFIG = {
    AccountingItemKeys.REVENUES: {
        'non_negative': True,
        'zero_leads_to_error': True,
        'help': "Total revenue or sales generated by the company",
    },
    AccountingItemKeys.COGS: {
        'non_negative': True,
        'zero_leads_to_error': False,
        'help': "Cost of Goods Sold - direct costs attributable to production",
    },
    AccountingItemKeys.DEPRECIATION_AMORTIZATION: {
        'non_negative': True,
        'zero_leads_to_error': False,
        'help': "Depreciation and Amortization expenses",
    },
    AccountingItemKeys.SALES_GENERAL_ADMIN: {
        'non_negative': True,
        'zero_leads_to_error': False,
        'help': "Sales, General and Administrative expenses",
    },
    AccountingItemKeys.ACCOUNTS_RECEIVABLE: {
        'non_negative': True,
        'zero_leads_to_error': False,
        'help': "Money owed to the company by customers (current asset)",
    },
    AccountingItemKeys.CURRENT_ASSETS: {
        'non_negative': True,
        'zero_leads_to_error': False,
        'help': "All assets that could be expected to be sold, consumed, used (i.e. converted to cash) within one year",
    },
    AccountingItemKeys.CURRENT_LIABILITIES: {
        'non_negative': True,
        'zero_leads_to_error': False,
        'help': "Obligations due within one year",
    },
    AccountingItemKeys.TOTAL_ASSETS: {
        'non_negative': True,
        'zero_leads_to_error': True,
        'help': "Sum of all owned resources with economic value",
    },
    AccountingItemKeys.PPE: {
        'non_negative': True,
        'zero_leads_to_error': False,
        'help': "Property, Plant and Equipment (net of depreciation)",
    },
    AccountingItemKeys.LONG_TERM_DEBT: {
        'non_negative': True,
        'zero_leads_to_error': False,
        'help': "Loans and financial obligations lasting over one year",
    },
    AccountingItemKeys.NET_INCOME: {
        'non_negative': False,
        'zero_leads_to_error': False,
        'help': "Profit after all expenses and taxes (bottom line)",
    },
    AccountingItemKeys.CFO: {
        'non_negative': False,
        'zero_leads_to_error': False,
        'help': "Cash Flow from Operating Activities",
    },
}

ACCOUNTING_ITEMS_LONG_NAME_CONFIG = {FINANCIAL_STATEMENTS_CONFIG[short_name].long_name: val
                                     for short_name, val in ACCOUNTING_ITEMS_CONFIG.items()}

PREV_YEAR_COL_NAME = 'Previous year'
CURRENT_YEAR_COL_NAME = 'Current year'

WINSORIZE_VALUES = {
    'DSRI': (0.27, 3.12),
    'GMI': (0.108, 4.880),
    'AQI': (0.1, 4.09),
    'SGI': (0.49, 4.88),
    'DEPI': (0.36, 2.65),
    'SGAI': (0.37, 2.19),
    'LVGI': (0.17, 3.13),
    'TATA': (-0.6, 0.25)
}


def get_accounting_item_names(use_long_name: bool) -> list:
    short_names = list(ACCOUNTING_ITEMS_CONFIG.keys())
    if use_long_name:
        return get_long_names(short_names=short_names)
    return short_names


def get_long_names(short_names: {list, str}) -> {str, list}:
    if isinstance(short_names, str):
        return FINANCIAL_STATEMENTS_CONFIG[short_names].long_name
    else:
        return [FINANCIAL_STATEMENTS_CONFIG[name].long_name for name in short_names]


def get_non_negative_accounting_item_names(use_long_name: bool) -> list:
    short_names = [k for k, v in ACCOUNTING_ITEMS_CONFIG.items() if v['non_negative']]
    if use_long_name:
        return get_long_names(short_names=short_names)
    return short_names


def get_non_zero_accounting_item_names(use_long_name: bool) -> list:
    short_names = [k for k, v in ACCOUNTING_ITEMS_CONFIG.items() if v['zero_leads_to_error']]
    if use_long_name:
        return [FINANCIAL_STATEMENTS_CONFIG[name].long_name for name in short_names]
    return short_names


def initialize_session_state():
    """Initialize all required session state keys"""
    if 'analysis' not in st.session_state:
        st.session_state.analysis = {}

    if 'accounting_inputs' not in st.session_state:
        st.session_state.accounting_inputs = {}

    if 'winsorize' not in st.session_state:
        st.session_state.winsorize = True

    if 'in_millions' not in st.session_state:
        st.session_state.in_millions = True  # Default to millions

    if 'prev_year_display' not in st.session_state:
        st.session_state.prev_year_display = PREV_YEAR_COL_NAME

    if 'curr_year_display' not in st.session_state:
        st.session_state.curr_year_display = CURRENT_YEAR_COL_NAME

    # Initialize all input keys
    default_df = get_default_df()
    for index_item in default_df.index:
        for col in default_df.columns:
            key = f"{index_item.lower()}_{col.lower().replace(' ', '_')}"
            input_key = f"input_{key}"
            if input_key not in st.session_state:
                st.session_state[input_key] = ""


def check_identity(id_input: str) -> bool:
    """
    Pattern explanation:
    ^(.*\s)? -> Optional: any characters followed by a space (company name with space)
    |^(.*[^\s])? -> OR any characters without trailing space (company name without space)
    [^@\s]+@[^@\s]+\.[^@\s]+$ -> Valid email format
    """
    pattern = r'^((.*\s)|(.*[^\s]))?[^@\s]+@[^@\s]+\.[^@\s]+$'
    return bool(re.fullmatch(pattern, id_input))


@st.dialog("Set your SEC identifier")
def set_your_identity():
    """Opens up a dialog window asking user to input an identifier"""
    st.write(
        "Enter an identity that the SEC can use to track their traffic.\n\nShould be in the form of "
        "'Name AdminContact@<domain>.com'\n(See https://www.sec.gov/os/accessing-edgar-data)")

    # Initialize state variables
    if 'identity_submitted' not in st.session_state:
        st.session_state.identity_submitted = False
    if 'identity_error' not in st.session_state:
        st.session_state.identity_error = None

    if 'pending_ticker' not in st.session_state:
        st.session_state.pending_ticker = st.session_state.ticker_input.upper()

    def on_enter():
        # This runs when user presses Enter in the text input
        if st.session_state.identity_input:
            if check_identity(id_input=st.session_state.identity_input):
                st.session_state['identifier'] = st.session_state.identity_input
                st.session_state.identity_submitted = True
                st.session_state.identity_error = None
            else:
                st.session_state.identity_error = "âŒ Invalid format. Please use: 'Name contact@domain.com'"
                st.session_state.identity_submitted = False
                # Force the dialog to stay open by preventing rerun
                st.session_state.dialog_should_close = False

    # Display error message if exists
    if st.session_state.identity_error:
        st.error(st.session_state.identity_error)

    # Text input with on_change handler
    st.text_input(
        "ðŸ¥¸ Enter your SEC identifier",
        placeholder="e.g. Kendal Roy num1boi@waystarroycompany.com",
        label_visibility="collapsed",
        key="identity_input",
        on_change=on_enter
    )

    # Only close if we have a valid submission
    if st.session_state.get('identity_submitted', False):
        st.session_state.identity_submitted = False
        st.session_state.identity_error = None
        st.rerun()


def get_default_df() -> pd.DataFrame:
    """Returns a DataFrame with default empty values"""
    return pd.DataFrame(
        {
            PREV_YEAR_COL_NAME: 12 * [''],
            CURRENT_YEAR_COL_NAME: 12 * ['']
        },
        index=get_accounting_item_names(use_long_name=True)
    )


def on_ticker_change():
    """Handle ticker change event"""
    ticker = st.session_state.ticker_input.upper()

    if ticker:
        if 'identifier' not in st.session_state:
            # Store the ticker that needs to be processed after identity is set
            st.session_state.pending_ticker = ticker
            set_your_identity()
        else:
            set_identity(user_identity=st.session_state.identifier)

            # Check if there's a pending ticker from the identity dialog
            if ('pending_ticker' in st.session_state) and st.session_state.pending_ticker:
                ticker = st.session_state.pending_ticker
                st.session_state.ticker_input = ticker  # Ensure the input shows the ticker
                del st.session_state.pending_ticker  # Clear the pending ticker
            try:
                if ticker not in st.session_state.analysis:
                    st.session_state.analysis[ticker] = CompanyAnalysis(ticker=ticker)
                df = get_accounting_input_data(ticker=ticker)
                set_session_state_accounting_items_from_df(df=df)
                unit = " (USD millions)" if st.session_state.get('in_millions', True) else ""
                st.success(f"Financial data loaded for {ticker}: Trailing twelve months{unit}")
            except ValueError as e:
                st.error(e, icon="ðŸš¨")
                clear_data()
                return
    else:
        clear_data()


def clear_data():
    """Clear all input data"""
    st.session_state.ticker_input = ""
    default_df = get_default_df()
    set_session_state_accounting_items_from_df(df=default_df)
    st.session_state.prev_year_display = PREV_YEAR_COL_NAME
    st.session_state.curr_year_display = CURRENT_YEAR_COL_NAME


def set_session_state_accounting_items_from_df(df: pd.DataFrame):
    """Update session state with values from DataFrame"""
    for index_item in df.index:
        for col in df.columns:
            key = f"{index_item.lower()}_{col.lower().replace(' ', '_')}"
            input_key = f"input_{key}"
            st.session_state[input_key] = str(df.loc[index_item, col])


def get_accounting_input_data(ticker: str) -> pd.DataFrame:
    """Get accounting data for ticker"""
    if ticker:
        if ticker not in st.session_state.accounting_inputs:
            # Use CompanyAnalysis to fetch data here (should only be done ONCE for each ticker)
            st.session_state.accounting_inputs[ticker] = get_accounting_data_from_sec(ticker=ticker)

        df = st.session_state.accounting_inputs[ticker].copy()

        st.session_state['prev_year_display'] = df.columns[0]
        st.session_state['curr_year_display'] = df.columns[1]

        df.columns = [PREV_YEAR_COL_NAME, CURRENT_YEAR_COL_NAME]

        # Convert to millions if the toggle is on
        if st.session_state.get('in_millions', True):
            df /= 1e6
            df = df.round(2)  # Round to 2 decimals

        return df
    else:
        return get_default_df()


# @st.cache_data
def get_accounting_data_from_sec(ticker: str) -> pd.DataFrame:
    """
    Returns a DataFrame with all the accounting item names as index and two columns (previous and current year).
    :param ticker: str
    :return: DataFrame
    """
    analyst = st.session_state.analysis[ticker]

    # Load income statement, cash flow statement and balance sheet for the past 8 periods with trailing twelve months
    accounting_item = get_accounting_item_names(use_long_name=False)
    data = analyst.get_accounting_items(accounting_item=accounting_item, periods=5, frequency='ttm',
                                        dates_as_cols=False, dates_ascending_order=True)
    data = data.iloc[:, [0, -1]].copy()
    data = clean_sec_dataframe(df=data)  # Change sign for negative values that should be positive
    return data


def clean_sec_dataframe(df: pd.DataFrame) -> pd.DataFrame:
    """
    Changes sign on any negative values that should be positive (all except Net Income and Cash from Operations)
    :param df: DataFrame(index=accounting items, cols=prev. and current year data (dates as col names))
    :return: DataFrame(index=accounting items, cols=prev. and current year data (dates as col names))
    """
    # Copy DataFrame first
    df = df.copy()

    # Exclude accounting names that can be negative
    exclude_indices = [FINANCIAL_STATEMENTS_CONFIG[short_name].long_name
                       for short_name in [AccountingItemKeys.NET_INCOME, AccountingItemKeys.CFO]]
    # Take absolute value for all rows not in exclude_indices
    df.loc[~df.index.isin(exclude_indices)] = df.loc[~df.index.isin(exclude_indices)].abs()
    return df


def display_wiki():
    """Display information about M-Score"""
    with st.expander("Information â„¹ï¸"):
        st.subheader("Beneish M-Score")
        st.write(
            "The Beneish M-Score is a numerical formula that aims to identify companies that are engaging in earnings manipulation. "
            "Developed by Professor Messod Beneish, it uses eight financial ratios to detect the likelihood of financial statement fraud."
        )

        st.markdown("**Key Features:**")
        st.write("- Scores above -1.78 suggest potential earnings manipulation")
        st.write("- Model is estimated using non-financial firms")
        st.write("- Has a fairly large error rate so don't overinterpret the result")
        st.write("- Financial companies were excluded from the model calibration")

        st.markdown("**M-Score Formula:**")
        st.latex(r'''
            \begin{aligned}
            M\text{-}Score &= -4.84 \\
            &\quad + 0.920 \times DSRI \\
            &\quad + 0.528 \times GMI \\
            &\quad + 0.404 \times AQI \\
            &\quad + 0.892 \times SGI \\
            &\quad + 0.115 \times DEPI \\
            &\quad - 0.172 \times SGAI \\
            &\quad + 4.679 \times TATA \\
            &\quad - 0.327 \times LVGI
            \end{aligned}
        ''')

        st.markdown("**Variables Explained:**")

        st.markdown("""
        - **DSRI (Days' Sales in Receivables Index)**:  
          Measures the ratio of receivables to sales compared to the previous year.  
          Formula:  
          $$
          DSRI = \\frac{\\frac{Receivables_t}{Sales_t}}{\\frac{Receivables_{t-1}}{Sales_{t-1}}}
          $$
        """)

        st.markdown("""
        - **GMI (Gross Margin Index)**:  
          Compares the gross margin ratio between the previous and current year.  
          Formula:  
          $$
          GMI = \\frac{\\frac{Sales_{t-1} - COGS_{t-1}}{Sales_{t-1}}}{\\frac{Sales_t - COGS_t}{Sales_t}}
          $$
        """)

        st.markdown("""
        - **AQI (Asset Quality Index)**:  
          Measures the proportion of non-current assets (excluding PPE) to total assets.  
          Formula:  
          $$
          AQI = \\frac{1 - \\frac{CurrentAssets_t + PPE_t}{TotalAssets_t}}{1 - \\frac{CurrentAssets_{t-1} + PPE_{t-1}}{TotalAssets_{t-1}}}
          $$
        """)

        st.markdown("""
        - **SGI (Sales Growth Index)**:  
          Measures the ratio of current year sales to previous year sales.  
          Formula:  
          $$
          SGI = \\frac{Sales_t}{Sales_{t-1}}
          $$
        """)

        st.markdown("""
        - **DEPI (Depreciation Index)**:  
          Compares the depreciation rate between the previous and current year.  
          Formula:  
          $$
          DEPI = \\frac{\\frac{Depreciation_{t-1}}{PPE_{t-1} + Depreciation_{t-1}}}{\\frac{Depreciation_t}{PPE_t + Depreciation_t}}
          $$
        """)

        st.markdown("""
        - **SGAI (Selling, General and Administrative Expenses Index)**:  
          Measures the ratio of SG&A expenses to sales compared to the previous year.  
          Formula:  
          $$
          SGAI = \\frac{\\frac{SG\\&A_t}{Sales_t}}{\\frac{SG\\&A_{t-1}}{Sales_{t-1}}}
          $$
        """)

        st.markdown("""
        - **LVGI (Leverage Index)**:  
          Compares the debt-to-assets ratio between current and previous year.  
          Formula:  
          $$
          LVGI = \\frac{\\frac{LongTermDebt_t + CurrentLiabilities_t}{TotalAssets_t}}{\\frac{LongTermDebt_{t-1} + CurrentLiabilities_{t-1}}{TotalAssets_{t-1}}}
          $$
        """)

        st.markdown("""
        - **TATA (Total Accruals to Total Assets)**:  
          Measures the difference between net income and cash flows relative to total assets.  
          Formula:  
          $$
          TATA = \\frac{NetIncome_t - CFO_t}{TotalAssets_t}
          $$
        """)

        st.markdown("**Additional Resources**")
        st.write("- [Original Paper by Messod Beneish (1999)](https://ru.scribd.com/doc/33484680/The-Detection-of-Earnings-Manipulation-Messod-D-Beneish)")
        st.write("- [Follow-up Paper by Messod Beneish (2012)](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1998387)")
        st.write("- [Investopedia Explanation](https://www.investopedia.com/terms/b/beneishmodel.asp)")
        st.write("- [Youtube video made by smart handsome Swedish man](https://youtu.be/mepuPwcd1UE?si=fBRZp0bBP50XW3ST)")


def user_guide():
    """Display a user guide on the sidebar"""
    with st.expander("User Guide", expanded=False):
        st.markdown("""
        ## How to Use This Tool

        ### 1. Enter Ticker Symbol
        - Input a valid U.S. stock ticker (e.g., AAPL for Apple, Inc.)
        - Currently it does not work for ADRs like 'BABA' or 'ERIC'
        - Data will automatically download from SEC Edgar

        ### 2. Review/Edit Data
        - The app pre-fills financial data from SEC filings (latest trailing twelve month)
        - Manually verify or edit any values as needed

        ### 3. Calculate M-Score
        - Click "Calculate" to run the analysis
        - Results show:
          - ðŸŸ¢ Score â‰¤ -1.78: Low manipulation risk
          - ðŸŸ¡ Score -1.78 to -2: Possible manipulation
          - ðŸ”´ Score > -1.78: High manipulation risk

        ### Key Features
        - **Winsorize Option**: Limits extreme values per Beneish's methodology
        - **Data Validation**: Checks for negative/zero values where inappropriate
        - **Detailed Breakdown**: Shows all 8 components of the M-Score

        ### About the Beneish M-Score
        The M-Score identifies earnings manipulation using 8 financial ratios (see Wiki for details):
        1. DSRI - Days Sales in Receivables Index
        2. GMI - Gross Margin Index  
        3. AQI - Asset Quality Index
        4. SGI - Sales Growth Index
        5. DEPI - Depreciation Index
        6. SGAI - SG&A Expense Index
        7. LVGI - Leverage Index
        8. TATA - Total Accruals to Assets

        ### Interpretation
        - **Threshold**: -1.78
        - Scores above -1.78 suggest higher probability of manipulation
        - Scores below -2 suggest lower probability

        ### Tips
        - Investigate any score > -1.78 in detail
        - Use with other fundamental analysis tools
        """)

        st.markdown("""
        <style>
        .user-guide {
            font-size: 0.9em;
            line-height: 1.6;
        }
        .user-guide h3 {
            color: #2e86ab;
            margin-top: 1em;
        }
        .user-guide ul {
            padding-left: 1.5em;
        }
        </style>
        """, unsafe_allow_html=True)


def create_data_option_toggles():
    # Add both toggles in a row
    col1, col2, col3 = st.columns(3)
    with col1:
        st.toggle("Winsorize", key='winsorize',
                  help="Used to make the model more robust and less susceptible to the influence of extreme values")
    with col2:
        st.toggle("In millions", key='in_millions',
                  help="Display all values in millions (divided by 1,000,000)", on_change=on_ticker_change)
    with col3:
        st.toggle("Automatic calculation", key='automatic_calculation',
                  help="Calculates the score automatically after ticker has been loaded", value=True)


def create_input_form():
    """Create the main input form"""
    with st.form("financial_data_form"):
        st.subheader("Input data")
        st.write("Enter financial statement data for the latest financial reporting period and one year previously.")

        # Four buttons used to calculate, clear and reload data
        col1, col2, col3 = st.columns(3)
        with col1:
            submitted = st.form_submit_button("ðŸš€ Calculate", help="Calculate the Beneish M-Score using the below accounting data")
        with col2:
            st.form_submit_button("ðŸ—‘ï¸ Clear data", on_click=clear_data, help="Both the ticker and any inputted accounting data will be cleared")
        with col3:
            st.form_submit_button("ðŸ”„ï¸ Reload data", on_click=on_ticker_change, help="Reload data for original data for the specified ticker")
        default_df = get_default_df()
        num_data_cols = len(default_df.columns)

        # Create header
        cols = st.columns([1] + [1] * num_data_cols)
        with cols[0]:
            st.write("")
        with cols[1]:
            st.markdown(f"**{st.session_state['prev_year_display']}**")
        with cols[2]:
            st.markdown(f"**{st.session_state['curr_year_display']}**")

        # Create input rows
        cfo_ni_long_name = [FINANCIAL_STATEMENTS_CONFIG[AccountingItemKeys.CFO].long_name, FINANCIAL_STATEMENTS_CONFIG[AccountingItemKeys.NET_INCOME].long_name]
        for index_item in default_df.index:
            cols = st.columns([1] + [1] * num_data_cols)
            with cols[0]:
                st.markdown(f"**{index_item}**", help=ACCOUNTING_ITEMS_LONG_NAME_CONFIG[index_item]['help'])
            for i, col_name in enumerate(default_df.columns, 1):
                with cols[i]:
                    if index_item in cfo_ni_long_name and i == 1:
                        st.write('')
                    else:
                        key = f"{index_item.lower()}_{col_name.lower().replace(' ', '_')}"
                        input_key = f"input_{key}"
                        st.text_input(
                            f"{index_item} {col_name}",
                            key=input_key,
                            label_visibility="collapsed"
                        )
        return submitted, default_df


def check_variables(df: pd.DataFrame) -> tuple:
    """
    Checks so that all values are not negative and numeric
    Returns a tuple of (has_issues, message) where has_issues is boolean
    and message is a string describing the issues
    """
    issues = []

    # Check for null/missing values
    # Don't care about previous year for net income and cash from operations
    cfo_ni_long_name = [FINANCIAL_STATEMENTS_CONFIG[AccountingItemKeys.CFO].long_name, FINANCIAL_STATEMENTS_CONFIG[AccountingItemKeys.NET_INCOME].long_name]
    cfo_ni_df = df.loc[df.index.isin(cfo_ni_long_name), [CURRENT_YEAR_COL_NAME]].copy()
    non_cfo_ni_df = df.loc[~df.index.isin(cfo_ni_long_name)].copy()
    nan_act_itms = list(cfo_ni_df[cfo_ni_df.isna().any(axis=1)].index) + list(non_cfo_ni_df[non_cfo_ni_df.isna().any(axis=1)].index)
    if nan_act_itms:
        if len(nan_act_itms) == 1:
            msg = f"There are missing values for '{nan_act_itms[0]}'"
        else:
            msg = f"There are missing values for '%s' and '{nan_act_itms[-1]}'." % "', '".join(nan_act_itms[:-1])
        issues.append(msg)

    # Check for negative values where they shouldn't exist
    for idx in get_non_negative_accounting_item_names(use_long_name=True):
        if (df.loc[idx] < 0).values.any():
            issues.append(f"Negative values found in {idx} which should be positive.")

    # Check for zero values where division might occur
    for idx in get_non_zero_accounting_item_names(use_long_name=True):
        if (df.loc[idx] == 0).any():
            issues.append(f"Zero values found in {idx} which may cause division errors in calculations.")

    if issues:
        return True, "WARNING: " + " ".join(issues)
    return False, "All input data appears valid."


def calculate_m_score_variables(df: pd.DataFrame, winsorize: bool) -> dict:
    """
    returns a dict with the 8 index variable used in the M score
    :param df: DataFrame
    :param winsorize: bool
    :return: dict
    """

    # Extract current year values
    curr_year_data = df[CURRENT_YEAR_COL_NAME]
    prev_year_data = df[PREV_YEAR_COL_NAME]

    result = {
        'DSRI': calculate_dsri(curr_year_data=curr_year_data, prev_year_data=prev_year_data),
        'GMI': calculate_gmi(curr_year_data=curr_year_data, prev_year_data=prev_year_data),
        'AQI': calculate_aqi(curr_year_data=curr_year_data, prev_year_data=prev_year_data),
        'SGI': calculate_sgi(curr_year_data=curr_year_data, prev_year_data=prev_year_data),
        'DEPI': calculate_depi(curr_year_data=curr_year_data, prev_year_data=prev_year_data),
        'SGAI': calculate_sgai(curr_year_data=curr_year_data, prev_year_data=prev_year_data),
        'LVGI': calculate_lvgi(curr_year_data=curr_year_data, prev_year_data=prev_year_data),
        'TATA': calculate_tata(curr_year_data=curr_year_data)
    }

    if winsorize:
        for k, v in result.copy().items():
            if np.isnan(v):
                result[k] = np.nan
            else:
                result[k] = max(min(WINSORIZE_VALUES[k]), min(max(WINSORIZE_VALUES[k]), v))

    return result


def calculate_dsri(curr_year_data: pd.Series, prev_year_data: pd.Series):
    return (curr_year_data[get_long_names(AccountingItemKeys.ACCOUNTS_RECEIVABLE)] / curr_year_data[get_long_names(AccountingItemKeys.REVENUES)]) / \
        (prev_year_data[get_long_names(AccountingItemKeys.ACCOUNTS_RECEIVABLE)] / prev_year_data[get_long_names(AccountingItemKeys.REVENUES)])


def calculate_gmi(curr_year_data: pd.Series, prev_year_data: pd.Series):
    return (prev_year_data[get_long_names(AccountingItemKeys.REVENUES)] - prev_year_data[get_long_names(AccountingItemKeys.COGS)]) / prev_year_data[get_long_names(AccountingItemKeys.REVENUES)] / \
        ((curr_year_data[get_long_names(AccountingItemKeys.REVENUES)] - curr_year_data[get_long_names(AccountingItemKeys.COGS)]) / curr_year_data[get_long_names(AccountingItemKeys.REVENUES)])


def calculate_aqi(curr_year_data: pd.Series, prev_year_data: pd.Series):
    return (1 - (curr_year_data[get_long_names(AccountingItemKeys.CURRENT_ASSETS)] + curr_year_data[get_long_names(AccountingItemKeys.PPE)]) / curr_year_data[get_long_names(AccountingItemKeys.TOTAL_ASSETS)]) / \
        (1 - (prev_year_data[get_long_names(AccountingItemKeys.CURRENT_ASSETS)] + prev_year_data[get_long_names(AccountingItemKeys.PPE)]) / prev_year_data[get_long_names(AccountingItemKeys.TOTAL_ASSETS)])


def calculate_sgi(curr_year_data: pd.Series, prev_year_data: pd.Series):
    return curr_year_data[get_long_names(AccountingItemKeys.REVENUES)] / prev_year_data[get_long_names(AccountingItemKeys.REVENUES)]


def calculate_depi(curr_year_data: pd.Series, prev_year_data: pd.Series):
    return (prev_year_data[get_long_names(AccountingItemKeys.DEPRECIATION_AMORTIZATION)] / (prev_year_data[get_long_names(AccountingItemKeys.PPE)] + prev_year_data[get_long_names(AccountingItemKeys.DEPRECIATION_AMORTIZATION)])) / \
        (curr_year_data[get_long_names(AccountingItemKeys.DEPRECIATION_AMORTIZATION)] / (curr_year_data[get_long_names(AccountingItemKeys.PPE)] + curr_year_data[get_long_names(AccountingItemKeys.DEPRECIATION_AMORTIZATION)]))


def calculate_sgai(curr_year_data: pd.Series, prev_year_data: pd.Series):
    return (curr_year_data[get_long_names(AccountingItemKeys.SALES_GENERAL_ADMIN)] / curr_year_data[get_long_names(AccountingItemKeys.REVENUES)]) / \
        (prev_year_data[get_long_names(AccountingItemKeys.SALES_GENERAL_ADMIN)] / prev_year_data[get_long_names(AccountingItemKeys.REVENUES)])


def calculate_lvgi(curr_year_data: pd.Series, prev_year_data: pd.Series):
    return (curr_year_data[get_long_names(AccountingItemKeys.LONG_TERM_DEBT)] + curr_year_data[get_long_names(AccountingItemKeys.CURRENT_LIABILITIES)]) / curr_year_data[get_long_names(AccountingItemKeys.TOTAL_ASSETS)] / \
        ((prev_year_data[get_long_names(AccountingItemKeys.LONG_TERM_DEBT)] + prev_year_data[get_long_names(AccountingItemKeys.CURRENT_LIABILITIES)]) / prev_year_data[get_long_names(AccountingItemKeys.TOTAL_ASSETS)])


def calculate_tata(curr_year_data: pd.Series):
    return (curr_year_data[get_long_names(AccountingItemKeys.NET_INCOME)] - curr_year_data[get_long_names(AccountingItemKeys.CFO)]) / curr_year_data[get_long_names(AccountingItemKeys.TOTAL_ASSETS)]


def calculate_beneish_m_score(df: pd.DataFrame, winsorize: bool):
    """Calculate Beneish M-Score based on provided financial data"""
    try:
        variables = calculate_m_score_variables(df=df, winsorize=winsorize)
        # Calculate M-Score
        m_score = (-4.84 + 0.92 * variables['DSRI']
                   + 0.528 * variables['GMI']
                   + 0.404 * variables['AQI']
                   + 0.892 * variables['SGI']
                   + 0.115 * variables['DEPI']
                   - 0.172 * variables['SGAI']
                   + 4.679 * variables['TATA']
                   - 0.327 * variables['LVGI'])

        return m_score

    except (KeyError, ZeroDivisionError, TypeError):
        return None


def main():

    # Initialize session state
    initialize_session_state()

    # Check if we have a pending ticker after identity was set
    if ('pending_ticker' in st.session_state) and st.session_state.pending_ticker and ('identifier' in st.session_state):
        on_ticker_change()  # This will now process the pending ticker

    # Title
    st.title("Manipulation-Score ðŸ“ˆ")
    m_score_placeholder = st.empty()

    # Wiki page about Beneish M-score
    display_wiki()

    # Page acting as a guide for the user
    user_guide()

    # SEC download section
    st.subheader("Download data from SEC for U.S. stocks")
    st.text_input("ðŸ”Ž Enter ticker", placeholder="ðŸ”Ž Enter ticker", key="ticker_input", on_change=on_ticker_change,
                  label_visibility='collapsed')

    # Calculation details
    calculation_expander = st.expander("Calculation details", expanded=False)
    with calculation_expander:
        results_placeholder = st.empty()

    # Toggles for calculation settings
    create_data_option_toggles()

    # Create and handle form
    submitted, default_df = create_input_form()

    # Collect values
    data = {}
    for col_name in default_df.columns:
        col_values = []
        for index_item in default_df.index:
            key = f"{index_item.lower()}_{col_name.lower().replace(' ', '_')}"
            input_key = f"input_{key}"
            value = st.session_state[input_key]
            col_values.append(float(value) if value else np.nan)
        data[col_name] = col_values

    accounting_input_df = pd.DataFrame(data, index=default_df.index)

    # Calculate the M-score always if applicable or when button is pushed
    if submitted or st.session_state['automatic_calculation'] and not accounting_input_df.isnull().values.all():
        try:

            has_issues, message = check_variables(accounting_input_df)

            m_score = calculate_beneish_m_score(accounting_input_df, st.session_state.winsorize)

            if m_score is not None:

                variables = calculate_m_score_variables(df=accounting_input_df, winsorize=st.session_state.winsorize)

                # Display M-Score result
                with m_score_placeholder.container():
                    if has_issues:
                        st.warning(message)
                    if np.isnan(m_score):
                        st.error(f"**âš ï¸ {m_score:.2f}** Not well defined score. Check 'calculation details'")
                    elif m_score > -1.78:
                        st.error(f"**ðŸš¨ {m_score:.2f}** Possible earnings manipulation")
                    elif -2 < m_score <= -1.78:
                        st.error(f"**ðŸ¤” {m_score:.2f}** Earnings might be manipulated but less likely")
                    else:
                        st.success(f"**ðŸ†— {m_score:.2f}** Likely no manipulation")
                    st.markdown("> *Threshold: -1.78 (scores above may indicate manipulation)*")

                # Display calculation details
                with results_placeholder.container():
                    st.subheader("Beneish M-Score Components")
                    components = [
                        ("DSRI (Days Sales in Receivables Index)", variables['DSRI'], "0.920"),
                        ("GMI (Gross Margin Index)", variables['GMI'], "0.528"),
                        ("AQI (Asset Quality Index)", variables['AQI'], "0.404"),
                        ("SGI (Sales Growth Index)", variables['SGI'], "0.892"),
                        ("DEPI (Depreciation Index)", variables['DEPI'], "0.115"),
                        ("SGAI (SG&A Expense Index)", variables['SGAI'], "-0.172"),
                        ("LVGI (Leverage Index)", variables['LVGI'], "-0.327"),
                        ("TATA (Total Accruals to Total Assets)", variables['TATA'], "4.679")
                    ]

                    table = "| Component | Value | Weight |\n|-----------|-------|--------|\n"
                    for name, value, weight in components:
                        table += f"| {name} | {value:.4f} | {weight} |\n"
                    st.markdown(table)

                    st.markdown("**M-Score Formula:**")
                    st.latex(r'''
                    \begin{aligned}
                    M\text{-}Score &= -4.84 \\
                    &\quad + 0.920 \times DSRI \\
                    &\quad + 0.528 \times GMI \\
                    &\quad + 0.404 \times AQI \\
                    &\quad + 0.892 \times SGI \\
                    &\quad + 0.115 \times DEPI \\
                    &\quad - 0.172 \times SGAI \\
                    &\quad + 4.679 \times TATA \\
                    &\quad - 0.327 \times LVGI
                    \end{aligned}
                    ''')
            else:
                with m_score_placeholder.container():
                    st.warning("Could not calculate M-Score - please ensure all required fields are filled")

        except ValueError:
            st.error("Please enter valid numerical values")


if __name__ == '__main__':
    main()


